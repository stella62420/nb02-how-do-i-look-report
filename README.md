# 📄 **How Do I Look 개인 개발 리포트**

## 1. **프로젝트 개요**

**프로젝트명**: **How Do I Look** 

**프로젝트 목적**: 본 프로젝트는 사용자가 자신의 정보를 큐레이팅하고, 이를 안전하게 관리(생성, 조회, 수정, 삭제)할 수 있는 백엔드 시스템을 구축하는 것을 목적으로 합니다. 특히, 이번 프로젝트는 저의 **첫 협업 프로젝트이자 프론트엔드 연동 경험**이라는 점에서 큰 의의를 둡니다. 또한 데이터의 유효성을 엄격하게 검증하는 데 주안점을 두었습니다.

**핵심 기능**:

* 사용자 큐레이션 생성, 조회, 수정, 삭제 기능 구현
* 비밀번호 기반 큐레이팅 접근 제어 및 인증 시스템 구축
* API 요청 데이터에 대한 포괄적인 유효성 검증 체계 확립

## 2. **담당한 작업**

**역할**: CURATION API

**기여 내용**:
본 프로젝트에서는 주로 큐레이팅 관련 API 기능 개발에 역량을 집중하였습니다.

* **큐레이팅 서비스 로직 구현 및 강화**:
    * 신규 큐레이팅 생성 시, 사용자로부터 입력받는 비밀번호를 `bcrypt` 라이브러리를 활용하여 안전하게 해싱한 후 데이터베이스에 저장하는 과정을 구현하였습니다. 이 과정에서 **이중 해싱을 방지하기 위한 안전장치** 또한 포함되었습니다.
    * 큐레이팅 수정 및 삭제 요청 시, 사용자 제공 비밀번호와 데이터베이스에 저장된 해시된 비밀번호를 비교하여 인증하는 로직을 구축하였습니다. 비밀번호 불일치 시에는 **403 Forbidden 에러를 반환하여 무단 접근을 효과적으로 방지**하였습니다.
    * 각 서비스 함수 내에서 리소스 미발견(`404 Not Found`), 유효성 검사 실패(`400 Bad Request`), 권한 없음(`403 Forbidden`) 등 비즈니스 로직에 따른 다양한 에러 상황에 대해 `statusCode`를 포함하는 **커스텀 에러 객체를 명확하게 정의하고 이를 반환**하도록 통일하여 에러 처리의 효율성을 증대시켰습니다.

* **API 유효성 검사 시스템 통합**:
    * 모든 큐레이팅 관련 API(생성, 조회, 수정, 삭제) 요청에 `validateRequest` 미들웨어를 적용하였습니다. 이를 통해 컨트롤러가 직접 `req.params`, `req.body`, `req.query`를 검증하는 대신, 사전 검증된 `req.validated` 객체를 활용하도록 리팩토링하여 코드의 가독성 및 안정성을 제고하였습니다. (`validateRequest` 미들웨어는 팀에서 공통으로 사용하는 유효성 검사 미들웨어입니다.)
    * 큐레이팅 생성 라우트에는 `hashPasswordMiddleware`를 추가하여 비밀번호 해싱 로직을 API 게이트웨이 단에서 처리함으로써, 서비스 로직의 부담을 경감하고 관심사 분리를 달성하였습니다. (해당 미들웨어는 팀에서 제공한 모듈을 적용하였습니다.)

* **문서화**:
    * `README.md` 파일에 Curation API의 주요 기능, 요청/응답 예시, 관련 코드 링크 등을 상세히 기술하여 팀원들이 큐레이팅 API를 더 용이하게 이해하고 활용할 수 있도록 지원하였습니다.

* **예상치 못한 문제 해결**: 프로젝트 진행 과정에서 프론트엔드와 로컬 환경에서 연동하는 과정에서 예상치 못한 오류가 빈번하게 발생하여 시스템 통합에 어려움을 겪었습니다. 특히, API 요청이 정상적으로 서버에 도달하지 않거나, 응답 데이터 처리 과정에서 문제가 발생하여 기능 구현 자체보다 연동 및 디버깅에 상당한 시간이 소요되었습니다. 결국, 로컬 연동 문제를 완전히 해결하지 못하고 시연 프로그램에서 연동하는 방식으로 진행되었습니다.

## 3. **기술적 성과**

**사용 기술 스택**:

* **백엔드**: Node.js, Express.js
* **데이터베이스**: PostgreSQL
* **보안**: `bcrypt.js` (비밀번호 해싱/비교)
* **유효성 검사**: `validateRequest` 미들웨어 

**구현한 주요 기능**:

* **안전한 큐레이팅 비밀번호 관리**: 사용자 큐레이팅 설정 비밀번호는 `bcrypt.js` 라이브러리의 강력한 단방향 해시 함수를 사용하여 저장되었습니다. 이는 데이터베이스 유출 시에도 민감 정보가 외부에 노출되는 위험을 최소화하여 보안성을 강화하는 데 기여합니다.
* **강력한 큐레이팅 접근 제어**: 큐레이팅 수정 및 삭제 시 사용자로부터 비밀번호를 입력받아, 저장된 해시 값과 비교하는 인증 시스템이 구축되었습니다. 이를 통해 큐레이팅 소유자만이 자신의 데이터를 변경하거나 삭제할 수 있도록 하여 데이터 무결성을 확보하였습니다.
* **통합된 요청 유효성 검증**: `validateRequest` 미들웨어를 활용하여 모든 큐레이팅 관련 API 요청에 대한 스키마 기반 유효성 검사를 자동화하였습니다. 이는 잘못된 형식의 데이터가 백엔드 로직으로 유입되는 것을 원천적으로 차단하며, 안정적인 API 서비스 제공에 필수적인 역할을 수행합니다.

## 4. **문제점 및 해결 과정**

**문제점**:

* **상황 (Situation)**: 큐레이팅 기능 개발 이후 프론트엔드와 로컬 환경에서 연동하는 과정에서 예상치 못한 오류가 빈번하게 발생하여 시스템 통합에 어려움을 겪었습니다. 특히, API 요청이 정상적으로 서버에 도달하지 않거나, 응답 데이터 처리 과정에서 문제가 발생하여 기능 구현 자체보다 연동 및 디버깅에 상당한 시간이 소요되었습니다. 이로 인해 최종 시연은 프론트엔드 로컬 연동이 아닌 별도의 시연 프로그램을 통해 진행하게 되었습니다.
* **과제 (Task)**:
    * 프론트엔드와 백엔드 간의 통신 오류를 정확하게 식별하고 해결하는 것이 요구되었습니다.
    * 안정적인 로컬 개발 환경을 구축하고, 연동 과정에서 발생할 수 있는 잠재적 문제점을 사전에 방지하는 방안을 모색해야 했습니다.
    * 문제 해결 과정을 통해 개발 효율성을 저해하는 요소를 식별하고 이에 대한 개선 방안을 모색해야 했습니다.

**해결 과정 (Action)**:

* **통신 오류 진단 및 시도**: 웹 브라우저의 개발자 도구(`Network` 탭)를 활용하여 프론트엔드에서 백엔드로 전송되는 HTTP 요청 및 응답을 면밀히 분석하고 문제점을 파악하려 시도했습니다. CORS(`Cross-Origin Resource Sharing`) 문제, 잘못된 엔드포인트 경로, 데이터 형식 불일치 등 다양한 가능성을 염두에 두고 디버깅을 진행했으나, 특정 문제점을 명확히 식별하고 해결하는 데 어려움이 있었습니다.
* **환경 설정 점검 및 시도**: 로컬 개발 환경에서 프론트엔드와 백엔드가 서로 다른 포트에서 실행될 경우 발생하는 문제를 해결하기 위해, `.env` 파일을 통해 백엔드 서버의 포트와 프론트엔드의 API 요청 기본 URL을 명확하게 정의하고 일관성 있게 관리하려 노력했습니다. 그러나 이 역시 완전한 해결로 이어지지는 못했습니다.
* **체계적인 디버깅 시도**: 오류 발생 시 단순히 코드 수정을 넘어, 문제의 근본 원인을 파악하기 위해 백엔드 서버 로그를 상세히 확인하고, 프론트엔드 콘솔의 에러 메시지를 분석하는 등 체계적인 디버깅 절차를 따르려 했습니다. 하지만 다양한 변수로 인해 문제의 원인을 명확히 특정하기 어려웠습니다.

**결과 (Result)**:

* 프론트엔드와 백엔드 간의 로컬 연동은 최종 시연에서 완전히 구현되지 못했습니다. 하지만 이 과정에서 API 통신 및 환경 설정 관련 다양한 문제 발생 가능성과 디버깅의 중요성을 직접 경험할 수 있었습니다.
* 예상보다 로컬 연동 및 디버깅에 시간이 다소 소요되었으며, 최종적으로 완전한 로컬 연동은 이루어지지 못했지만, 이 경험을 통해 시스템 통합 과정의 복잡성을 이해하고, 문제 발생 시 더욱 체계적으로 접근해야 한다는 중요한 교훈을 얻었습니다. 이 경험은 향후 프론트엔드와 백엔드 연동 프로젝트를 수행하는 데 귀중한 자산이 될 것입니다.

## 5. 협업 및 피드백

팀원들과의 협업 과정에서 정기적인 데일리 스크럼을 통해 진행 상황을 공유하고, 특히 기술적으로 난해한 부분에 대해 적극적인 질문과 논의를 수행하였습니다.


GitHub PR을 통한 코드 리뷰 과정은 제 코드의 품질 향상에 매우 중요한 역할을 담당하였습니다.

**배운 점**:

* 다른 팀원의 코드를 리뷰하면서 새로운 코딩 패턴 및 효율적인 문제 해결 방식을 습득하였으며, 이를 제 코드에 적용할 수 있는 유익한 사례들을 얻었습니다.
* 제가 작성한 코드에 대한 피드백을 통해 미처 고려하지 못했던 예외 처리나 코드 최적화 지점을 발견하고, 이를 개선하는 과정을 통해 개인적인 성장을 이룰 수 있었습니다. 특히, 에러 핸들링 방식 및 미들웨어 적용 순서에 대한 피드백은 아키텍처 설계에 대한 이해를 심화시키는 데 기여하였습니다.

**피드백 반영 예시**:

[`fix 큐레이팅 API 유효성 및 암호화 로직 개선 #(#258)`](https://github.com/gyunam-bark/nb02-how-do-i-look-team1/pull/258)

"초기 큐레이팅 생성 시 비밀번호 해싱 미들웨어의 위치에 대한 팀원과의 논의를 통해, `CurationService` 내에서 직접 해싱하는 대신 라우트 레벨의 미들웨어(`hashPasswordMiddleware`)에서 처리하는 것이 책임 분리에 더욱 적합하다는 피드백을 수용하여 반영하였습니다. 이는 중복 해싱 가능성을 배제하고 서비스 로직을 보다 간결하게 구성하는 데 기여하였습니다."

## 6. 코드 품질 및 최적화

**가독성 및 유지보수성**:

* **모듈화**: 큐레이팅 관련 로직을 `controllers`, `services`, `routes`, `middlewares`, `utils` 디렉토리로 명확하게 분리하여 각 파일이 단일 책임을 가지도록 설계하였습니다. 이는 특정 기능의 수정 또는 확장 시 관련 코드에 집중하여 작업할 수 있도록 합니다.
* **일관된 코딩 컨벤션**: ESLint 및 Prettier를 활용하여 프로젝트의 코딩 컨벤션을 일관되게 유지하기 위해 노력하였습니다. 특히, 변수명, 함수명, 파일명 규칙을 준수하여 코드의 통일성을 확보하였습니다.
* **주석**: 복잡한 비즈니스 로직이나 특정 설계 결정, 주요 함수의 역할에 대해 충분한 주석을 작성하여 코드의 이해도를 높였습니다.

**성능 최적화**:

* **효율적인 DB 쿼리**: PostgreSQL 사용 환경에서 N+1 쿼리 문제를 방지하기 위해 필요시 `JOIN` 또는 `IN` 절을 활용하여 데이터베이스 호출 횟수를 최소화하였습니다. 큐레이팅 조회 시에도 필수 필드만을 선택적으로 가져와 불필요한 데이터 전송을 경감시켰습니다.
* **미들웨어 활용**: `validateRequest` 미들웨어를 통해 컨트롤러 진입 이전에 부적절한 요청을 필터링함으로써, 불필요한 비즈니스 로직 연산을 방지하고 서버 리소스를 효율적으로 활용할 수 있도록 기여하였습니다.

## 7. 향후 개선 사항 및 제안

* **로컬 프론트엔드 연동 문제 심층 분석 및 해결**: 프로젝트 진행 중 발생했던 프론트엔드 로컬 연동 문제를 단순히 넘기지 않고, 향후 심층적으로 원인을 분석하고 해결 방안을 모색할 계획입니다. 이를 통해 프론트엔드와의 연동 과정을 더 깊이 이해하고, 안정적인 개발 환경 구축 역량을 강화하겠습니다.
* **포괄적인 테스트 코드 작성**: 현재는 주로 수동 테스트를 통해 큐레이팅 기능의 안정성을 확인하였으나, 향후에는 단위 테스트(`Unit Test`) 및 통합 테스트(`Integration Test`)를 작성하여 코드 변경에 따른 회귀 오류를 방지하고 시스템 안정성을 더욱 강화할 필요가 있습니다. 특히, 큐레이팅 비밀번호 해싱/비교 로직 및 유효성 검사 미들웨어에 대한 테스트 커버리지를 증대시키는 것이 중요하다고 사료됩니다.
* **글로벌 에러 핸들링 강화**: 본 프로젝트에서 전역 에러 핸들링에 대해 리서치하고 일부 적용하였으나, 아직 다양한 에러 상황(예: 데이터베이스 연결 오류, 서드파티 API 오류)에 대한 더욱 세분화된 처리 및 로깅 시스템을 구축하는 것이 필요합니다. `Winston` 또는 `Pino`와 같은 로깅 라이브러리를 도입하여 프로덕션 환경에서 발생하는 문제점을 신속하게 진단하고 대응할 수 있는 기반을 마련해야 합니다.
* **큐레이팅 접근 권한 확장**: 현재는 비밀번호 기반의 단순한 접근 제어만이 구현되어 있습니다. 향후 사용자 인증(예: JWT 기반 인증)을 도입하여 큐레이팅 소유자 전용 접근 기능, 혹은 특정 그룹에만 공유 가능한 기능 등 더욱 유연하고 다양한 접근 권한 관리 기능을 고려해볼 수 있습니다.
* **API 버전 관리 도입**: 서비스 확장 및 새로운 큐레이팅 관련 기능 추가 시, API 버전 관리(예: `/api/v1/curatings`)를 도입하여 기존 클라이언트와의 호환성을 유지하며 유연하게 시스템을 발전시켜 나갈 것을 제안합
